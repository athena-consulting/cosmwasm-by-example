# Block Timestamp Manipulation

The objective of this cosmwasm contract is to provide a comprehensive understanding of the block timestamp, and how they can be used to perform an attack on a DeFi project. We will define the term and elaborate on its workings, examining its potential consequences for the blockchain ecosystem.

---

## Introduction

At times, smart contract developers tend to use time-specific actions to execute some logic in the contract. As a result, they rely on the timestamp generated by the node running the smart contract. These specific actions can also be the execution of critical smart contract logic, such as a source of entropy to generate a random number that serves an actionable execution.

## Vulnerability

The timestamp dependence vulnerability occurs when the smart contract does an operation based on the value of the block timestamp. The timestamp value is generated by the node executing the smart contract, making it easily manipulated and vulnerable to attacks. One of the most challenging issues with blockchain technology is synchronizing the precise time between nodes due to the distributed nature of the network. However, comprehending the present time is probably inevitable during the development of smart contracts, especially as most smart contract development languages are Turing complete.

A smart contract can be exploited if it compares the node's timestamp value to a time value that will occur in less than 900 seconds. The timestamp value is referenced by the nodes that run the smart contract, which means that it can also be manipulated to be equal to a certain value.
A miner has the opportunity to set the timestamp as a value that would increase their chances of profiting from a logic, such as the function of the contract in which the timestamp is used as a source to generate randomness. This can be done within 15 seconds of block validation.
For instance, a lottery application might select a random bidder from a group of bidders using the block timestamp. A miner may enter the lottery and then modify the timestamp value to increase their chances of winning.

## Attack Explained

Consider this example contract provided here: 

```rust
#[cfg(not(feature = "library"))]
use cosmwasm_std::entry_point;
use cosmwasm_std::{DepsMut, Env, MessageInfo, Response, CosmosMsg};
use cw2::set_contract_version;

use crate::error::ContractError;
use crate::msg::{ExecuteMsg, InstantiateMsg};
use crate::state::PREVIOUS_BLOCK_TIME;

// version info for migration info
const CONTRACT_NAME: &str = "crates.io:block-timestamp-manipulation";
const CONTRACT_VERSION: &str = env!("CARGO_PKG_VERSION");

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    _msg: InstantiateMsg,
) -> Result<Response, ContractError> {
    let prev_block_time = 0;
    PREVIOUS_BLOCK_TIME
        .save(deps.storage, &prev_block_time)
        .unwrap();
    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION).unwrap();
    let msg=CosmosMsg::Bank(cosmwasm_std::BankMsg::Send { to_address: env.contract.address.to_string(), amount: info.funds });
    Ok(Response::new().add_attribute("method", "instantiate").add_message(msg))
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::Guess {} => execute::execute_guess(deps, env, info),
    }
}

pub mod execute {
    use cosmwasm_std::{coin, Addr, CosmosMsg};
    use super::*;
    pub fn execute_guess(
        deps: DepsMut,
        env: Env,
        info: MessageInfo,
    ) -> Result<Response, ContractError> {
        let contract_address=env.contract.address.to_string();
        let mut prev_block_time = PREVIOUS_BLOCK_TIME.load(deps.storage).unwrap();
        let required_fund=vec![coin(2, "earth")];
        if !(info.funds == required_fund ) {
            return Err(ContractError::InsufficientFunds());
        }

        if env.block.time.seconds() == prev_block_time {
            return Err(ContractError::BlockTimestampError());
        }

        prev_block_time = env.block.time.seconds();
        PREVIOUS_BLOCK_TIME
            .save(deps.storage, &prev_block_time)
            .unwrap();

        if env.block.time.seconds() % 7 == 0 {
            send_all_funds(deps, env, info.sender)?;
        }
        let msg=CosmosMsg::Bank(cosmwasm_std::BankMsg::Send { to_address: contract_address, amount: info.funds });

        Ok(Response::new().add_attribute("action", "guess").add_message(msg))
    }

    pub fn send_all_funds(deps: DepsMut, env: Env, to: Addr) -> Result<Response, ContractError> {
        let contract_balance = deps
            .querier
            .query_balance(env.contract.address, "earth")
            .unwrap()
            .amount;
        let msg = CosmosMsg::Bank(cosmwasm_std::BankMsg::Send {
            to_address: to.to_string(),
            amount: vec![coin(contract_balance.into(), "earth".to_string())],
        });
        Ok(Response::new()
            .add_attribute("action", "send_all_funds")
            .add_message(msg))
    }
}
```

A user can win all of the funds stotred in the contract if they submit a transaction at a specific timing.

In `state.rs` we have declared a constant global variable `PREVIOUS_BLOCK_TIME`, which is used to keep track of the block timestamp required in the contract.

During Instantiating of contract we have made the function to recieve funds during instantiation of the contract.

Inside `Guess` function which calls `execute_guess` we have conditional statements that states that the caller of the contract needs to send `2 "earth"` coins and another one which states there can't be more than 1 transaction originating from this contract at a given time.

Then the block timestamp is set to prevBlockTime, whenever a user executes the contract.

Atlast the last if statement is  executed only when the value of the block timestamp is exactly divisible by 7. When that happens, the balance of the contract is sent to the address that executes this contract.

## Attack Scenario

This contract is deployed with a certain funds for example `10 "earths"`. A malicious actor Eve, operates a very powerful miner which can alter the block timestamp value.
Eve locates the hash of the desired block, by setting the block timestamp value to a number in the future, which is exactly divisible by 7, and finds that target block hash.
This means that Eve's block is successfully added into the chain, and they take away the balance set in the contract.

## Prevention

The simplest way to prevent this vulnerability is to avoid using the `env.block.time` value on the contract altogether. The `env.block.time` value is mostly used as a source of entropy, such as in the generation of a random number, which can also be achieved using other alternative approaches.

---
